# Java Design Patterns (ASS 2 NURZHANOVA ZARINA)

# Singleton Design Pattern:

## **Описание:**

Паттерн Singleton обеспечивает, что у класса есть только один экземпляр, и предоставляет глобальную 
точку доступа к этому экземпляру.

## **Когда использовать:**

Когда требуется, чтобы у класса был только один экземпляр во всей программе.
Когда этот экземпляр должен быть доступен для всех остальных частей программы.

# Factory Design Pattern:

## **Описание:**

Паттерн Factory позволяет создавать экземпляры класса, не указывая конкретный класс в коде, используя интерфейс или абстрактный класс для создания объектов.

## **Когда использовать:**

Когда у вас есть некоторая общая логика по созданию объектов, но конкретные подклассы могут варьироваться.
Когда клиенту необходимо знать только об интерфейсе для создания объектов, а не о конкретной реализации.

# Builder Design Pattern:

## **Описание:**

Паттерн Builder позволяет 
конструировать сложные объекты, 
разделяя процесс пошагового 
построения от представления конечного объекта.

## **Когда использовать:**

Когда у вас есть объект с большим количеством параметров, некоторые из которых могут иметь значения по умолчанию.
Когда вы хотите иметь возможность создавать разные представления одного объекта.

# Prototype Design Pattern:

## **Описание:**

Паттерн Prototype позволяет создавать новые объекты путем копирования существующих объектов (прототипов).

## **Когда использовать:**

Когда создание нового объекта путем клонирования существующего является более эффективным, чем создание его с нуля.

# Proxy Design Pattern:

## **Описание:**

Паттерн Proxy предоставляет заместителя для другого объекта для контроля доступа к нему.

## **Когда использовать:**

Когда нужно ограничить доступ к некоторому объекту, добавляя дополнительную логику.
Когда нужно добавить логику до или после выполнения методов объекта.

# Facade Design Pattern:

## **Описание:**

Паттерн Facade предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

## **Когда использовать:**

Когда есть сложная система, и вы хотите предоставить упрощенный интерфейс для взаимодействия с ней.
Когда нужно скрыть сложность и детали реализации от клиентов.

# Composite Design Pattern:

## **Описание:**

Паттерн Composite позволяет сгруппировать множество объектов в древовидную структуру для работы с ними как с одним объектом.

## **Когда использовать:**

Когда вы хотите работать с отдельными объектами и их композициями в едином интерфейсе.
Когда вам нужна структура древовидного объекта.

# Composite Design Pattern:

## **Описание:**

Паттерн Composite позволяет сгруппировать множество объектов в древовидную 
структуру для работы с ними как с одним объектом. Этот паттерн используется, когда клиент должен 
работать с индивидуальными объектами и их композициями в едином интерфейсе.

## **Пример:**

Визуализация древовидной структуры файловой системы, где и папки, и файлы рассматриваются как компоненты.

# **Decorator Design Pattern:**

## **Описание:**

Паттерн Decorator позволяет динамически добавлять новую функциональность существующим объектам без изменения их структуры. 
Это достигается созданием нового класса-декоратора, который оборачивает оригинальный объект.

## **Пример:**

Возьмем пример кофейни. У нас есть базовый класс Coffee, и мы можем добавить к нему разные добавки (молоко, сахар и т.д.) без изменения основного класса.

# Flyweight Design Pattern:

## **Описание:**

Паттерн Flyweight позволяет эффективно разделять общие данные между множеством подобных объектов. 
Вместо хранения одинаковых данных в каждом объекте, используется общий объект для этих данных.

## **Пример:**

В текстовом редакторе, каждая буква в документе может быть представлена как объект, но сам текст (например, шрифт) может быть разделяемым для всех букв.

# Adapter Design Pattern:

## **Описание:**

Паттерн Adapter позволяет интерфейсу класса работать 
с другим интерфейсом, который он не поддерживает. 
Он предоставляет прослойку, которая переводит вызовы 
методов в формат, понятный целевому объекту.

## **Пример:**

Допустим, у вас есть старый компонент, который работает с интерфейсом A, но вы хотите использовать его с новым компонентом, имеющим интерфейс B. Адаптер преобразует вызовы методов интерфейса B в вызовы методов интерфейса A.

# Bridge Design Pattern:

## **Описание:**

Паттерн Bridge разделяет абстракцию и реализацию, позволяя им изменяться независимо друг от друга. Это позволяет легко расширять и изменять систему.

## **Пример:**

Представим, у вас есть форма и разные виды рендеринга (например, для веба и десктопа). Bridge позволяет менять типы рендеринга без изменения самих форм.

# Observer Design Pattern:

## **Описание:**

Паттерн Observer позволяет объектам оповещать других объектов 
об изменениях в своем состоянии. Это способ реализации подписки на события.

## **Пример:**

Рассмотрим мессенджер: когда один пользователь отправляет сообщение, все подписанные на него пользователи должны получить это сообщение.